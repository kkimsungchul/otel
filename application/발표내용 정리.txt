
https://youtu.be/EZmUxMtx5Fc?si=eLSLaShEMqekyrEy
※ 참고사항 해당영상은 2022년도 자료이며, 현재와는 다른내용이 있을 수 있음

# WHY

- 5:50
옵저버빌리티 (관측성, 관찰 가능성) 
시스템 혹은 애플리케이션이 어떤 데이터 값을 출력하면 
그 값을 가지고 시스템을 이해하는것
예를 들면
장애가 왜 발생했지?
왜 느려졌지?
사용자가 느끼는 속도는 빠를까?
라는 근본적인 원인을 찾는 것을 말함

모니터링과 옵저버빌리티의 차이점
모니터링은 애플리케이션에서 출력하는 값을 수집하고 확인하는 활동
옵저버빌리티는 이 모니터링 활동을 통해서 어떤 값을 가지고 근본적인 원인을 찾아가는 디버깅이 섞여있는 활동

옵저버리리티를 확보하기위해선 로그,지표,추적이 필요함
로그(log) : 로그는 시간기반 텍스트
지표(metric) : 런타임 환경에서 측정된 값
추적(trace) : 어떤 요청이 처리될 때 경로(큰그림)

로그는 시스템마다, 개발자마다 로그 규격이 다름
옵저버빌리티를 확보하는 측면에서는 구조화된 로그를 남기는 것을 권장함
구조화된 로그는, 쉽게말해 제이슨이나 프로퍼티파일에서 남기는 key:value 형태

지표는 런타임 환경에서 측정된 서비스값
대표적으로 호스트 관련 성능 지표
성능지표를 토대로 스케일아웃 또는 스케일업을 할때 기준 데이터를 정함

추적은 어떤 요청이 있을 때 어떤 시스템으로 흘러가는지, 
흘러갈때마다 시간이 얼마나 흘러가는지, 어떤 경로를 가지고 있는지 확인

옵저버빌리티 측면에서 가장 중요한건 트레이스임
성능 관련 문제가 발생했을 때 트레이스 없이는 분석하기가 힘듬

어떤 요청이 10초 걸린다고 예를 잡았을때
해당 요청에는 무수히 많은 시스템을 거처감
이럴때 로그에 어떤 요청인지, 누가요청했는지, 시간이 얼마나 걸리는지 남기면 찾을수 있음
하지만 이방법은 하나의 시스템 내에서는 쉽게 파악이 가능하지만
MSA 환경에서는 여러개의 컴포넌트들을 다 분석해야 할때는 현실적으로 어려움

- 10:50
트레이스는 추적이라고 하며, 분산추적을 의미함
트레이스는 여러개의 span으로 이뤄짐
스팬은 프로세스 처리과정 또는 그 안에서의 세부 과정을 말함
스팬에는 시작시간, 종료시간이 포함되며
트리구조다 보니 상위정보를 포함하고 있음

첫번째 스팬은 루트스팬이라고 부르며
첫번째 스팬의 소요시간을 확인하며 어떻게 돌아가는지 알수 있음

트레이스는 비동기 처리에서 더욱 빛을 발함
비동기 추적을 할때 어려움이 있음
자세한 경로를 기록하므로 개발자 혹은 운영자에게 시스템이 어떻게 돌아가는지 이해할수 있는 큰 그림을 제시해줌

-12:40
오픈텔레메트리는 간단하게 오텔이라불리며
옵저버릴리티를 도와주는 일종의 프레임워크
업계의 표준으로 자리잡고 있음
그라파나,예거,프로메테우스, 데이타독,와탭에서 오픈텔레메트리를 지원해주고있음

-13:10
오픈텔레메트리 컨셉

오픈텔레메트리는 원격 측정 데이터에 대해서
계측 수집부터 각종 API SDK등 다양한 도구를 제공하는 것을 목표로 삼고 있음
호환성 높은 모니터링 플랫폼 개발이 가능함

# HOW
다른 시스템 혹은 애플리케이션을 모니터링해야 하므로 고가용성
수많은 시스템을 모니터링 할 수 있는 능력이 필요함


17:35
모니터링플랫폼은 모니터링 어떻게?
오픈텔레메트리 콜렉터로 수집하여 관리
리시버 - 프로세스 - 익스포터

리시버 영역에서는 예거나 프로메테우스등의 각종 데이터 소스들로부터 데이터를 수신하거나 데이터를 직접 생성
생성된 데이터는 프로세스 라인을 거쳐서 
익스포터를 통해 원하는 백엔드로 전송함

공식문서, 깃허브 참고

18:30
콜렉터를 어떻게 배치하느냐에 따라서 Agent모드와 Gateway 모드로 불림
Agent모드는 애플리케이션과 동일한 호스트에서 실행
애플리케이션과 같은 레벨에서 실행

Gateway모드는 데이터 센터 또는 리전에서 독립적으로 실행, 같은 환경 내에 Agent로부터 데이터 수신
게이트웨이는 서비스 형태로 배포되는것을 말함

한 시스템 내에 6개의 서비스가 있다고 가정함
아래의 그림은 Agent 콜렉터가 없이 Gateway콜렉터만 존재함
------------------------------------------------------------
시스템 A ,시스템 B	|				|	예거			|
시스템 C ,시스템 D	| Gateway 콜렉터	|	프로메테우스	|	그라파나
시스템 E ,시스템 F	|				|	로키			|
------------------------------------------------------------
이 경우에 Gateway 콜렉터의 정보가 변경될 경우 A B C D E ...의 모든 시스템에서 정보를 변경해줘야함

여기에 Agent콜렉터를 애플케이션 레벨에 하나 추가하게되면 아래와 같은 형태로 변경되며
-----------------------------------------------------------------------
시스템 A ,시스템 B				|				|	예거			|
시스템 C ,시스템 D	Agent 콜렉터	| Gateway 콜렉터	|	프로메테우스	|	그라파나
시스템 E ,시스템 F				|				|	로키			|
-----------------------------------------------------------------------
시스템들에서 설정을 바꿀 필요없이 Agent 콜렉터에서만 Gateway콜렉터의 정보를 변경하면됨
어떻게 구성 하느냐에 따라서 콜렉터를 여러개 둘수가 있으며,
Gateway콜렉터를 여러개 구성하여 수신하는 항목을 각각 나눌수도 있음
Gateway콜렉터(metric)
Gateway콜렉터(span)
Gateway콜렉터(log)

30분부터 봐야함
http_server_requests_seconds_*
500대 에러 비율 확인 가능
초당 리퀘스트 확인
평균 응답시간 확인

500대 에러발생
-> 메트릭에서 확인
-> 트레이서 부분 확인
-> 트레이서 ID로 로그 조회


# Q&A
오픈텔레메트리 콜렉터에서 GRPC 로 리시버를 설정함
메트릭 정보를 오픈텔레메트리로 보냈는데

---
https://www.youtube.com/watch?v=uKATqtjK2eo
※ 해당 영상은 2021년9월 자료

용어와 아키텍처 설명
벤더 종속성이 없는 오픈소스기반에서의 옵저버빌리티 확보

1:05
옵저버빌리티 (관측가능성, 관찰가능성)
시스템의 속성을 자세히 설명하는데 사용하는 용어
도구들을 통해 시스템과 애플리케이션에서 발생하는 문제를 파악하는 것
원격측정(Telemetry) data

모니터링과 가장 큰 차이는
모니터링은 시스템의 상태를 확인하는거고
옵저버리리티는 시스템의 속성을 확인하고 원인분석을 통해서 장애의 근본 원인을 찾는것

Logs : 타임스탬프
Metrics : 키-밸류 태그를 가지는 집계/통계 데이터 (Gauge , Counter , Histogram 등)
Traces : 개별 Request가 전체 시스템에 전파(propagate)될 때 경로에 대한 기록

2:55
Distributed Trace(분산 추적)
시스템의 프로세스에서 특정 부분으 ㅣ지연(latency)를 알려주는 원격 측정 방법
요청이 마이크로서비스 및 서버리스 아키텍처를 통해 전파될 때 이동하는 경로를 기록
마이크로서비스 환경같은 최신 아키텍처에서 수많은 구성 요소간의 종속성과 관계를 측정하고
지연 병목을 찾아내는 도구이기 때문에 옵저버빌리티에서 매우 중요함

4:15
오픈트레이싱(OpenTracing) + 오픈센서스(OpenCensus)  = 오픈텔레메트리
오픈센서스 : 애플리케이션 메트릭과 분산 트레이스를 수집하기 위한 다양한 언어별 라이브러리 셋
오픈트레이싱 : 분산추적을 위한 벤더 중립적인 API와 계측

4:45
오픈텔레메트리란
옵저버빌리티에 필요한 데이터를 계측하고, 수집 내보내기를 해주는 도구

다양한 언어 지원
CSP : Azure , GCP , AWS 지원
모니터링 벤더 : Lightstep , Datadog , Dynatrace , Honeycomb, New Relic , Splunk, Stackdriver
벤더사에서는 대부분 오픈텔레메트리를 지원해주며, 해당 규격으로 개발을 하고 있음

9:11
컨텍스트 전파(Context Propagation)
Core Concept : 서비스간 트레이스 전달 규약 (W3C, Zipkin B3)

오픈텔레메트리의 핵심은 개발자가 보고싶을때 컨텍스트를 제공해주는 것

10:15
Trace : 서비스 요청에 대한 애플리케이션 또는 서비스 구조 확인하고,
모든 서비스들 간 데이터 흐름을 시각화하여 아키텍처상의 병목 현상을 파악

Span : 다양한 정보를 캡슐화(encapsulate)

전체의 흐름을 트레이스로 보고
그 안에 있는 정보들을 스팬, 스팬에는 부모 자식 스팬이 있음

11:50
Spans
Name , Timestamp(start , finish)
Attributes : 자유롭게 추가 가능한 키-벨류(Customer ID , Version , Host ID, 애플리케이션 버전 등)
Events : 타임스탬프 문자열 형태의 tuple(name, timestamp , attributes)
Links : span의 인과 관계
SpanContext : Span이 참조하는데 필요한 정보
TraceId : 전체 시스템 식별자, WorldWide 식별자(16 bytes array identifier)
SpanID (ParendId) : 서비스 레벨에서의 글로벌 변수, Globally in a service(8 Bytes array identifier)
TraceFlags : Optional , Sampling bit( 1 byte(8bit) , But only 1bit Used)
TraceState : Optional 키-밸류( ex, 벤더 식별 정보)

13:30
W3C Trace Context
상관 정보에 대한 전달 방법 표준
TraceParent : trace-id(TraceId) , span-id(SpanId) , sampling flag(TraceFlags)
TraceState

Baggage : 메트릭, 추적 및 로그에 사용자가 원하는 컨텍스트와 정보를 추가하는데 사용
 baggage : userId = alice , baggage : serverNode=node01
 https://w3c.github.io/baggage/

14:20
컨텍스트 도식화
UML다이어그램

trace ID
-> 스팬 시작 (trace ID , span ID)
->> 자식 스팬 시작 (trace ID , parent span ID , span ID)
->>> 자식 스팬 시작 (trace ID , parent span ID , span ID)
위의 내용에서 trace ID는 모두 똑같음
span ID는 해당 span의 고유 ID이며, parent span ID는 바로 상위의 span ID


16:20
오픈텔레메트리 아키텍처 설명

17:50
콜렉터 도식화

18:40
콜렉터 설명
리시버 ,프로세스,익스포터

메모리제약
배치 제약
샘플링 비율 (저장되는 트레이싱의 볼륨 설정)

20:22
파이프라인 구성 용이
백엔드 선택 자유
운영에 대한 용이성, 중앙에서 운영

콜렉터 성능
2018년도 구글 서밋에서 발표한 내용
1 collector , 24 core 48GB
초당 20만 Spans (17.3 billion span/day)
57TB/day
no dropped spans  (유실된 span이 하나도 없음)

21:15
자체 구축 데모 설명


23:00
Spring 구성 설명
Actuator , prometheus 사용해서 어플리케이션에서 바로 툴로 전송

24:30
Spring 수동 설정 (SDK)
어노테이션 사용방법 설명

데모 시연

30:30
샘플링
Span , Metric 에 key : value를 추가하게되면 데이터에 엄청난 비용이 발생할 수 있음
자체적으로 샘플링을 해서 데이터 수집에 대한 비용을 낮출수 있음
다만 샘플링 비율을 너무 높게 하면, 데이터 비용이 높고
너무 낮게하면 오차가 너무 심함
샘플링 값을 테스트 하여 원하는 샘플링 정책을 가져가는게 좋음

32:00
오픈텔레메트리 정리
벤더 중립적인 단일 계측 라이브러리(자동 및 수동 계측 모두 지원)
에이전트 또는 게이트웨이를 포함해 다양한 방법으로 배포할 수 있는 단일 콜렉터 바이너리
환경 구성을 통해 데이터를 여러 대상에 병렬로 전송 가능
데이터 수집을 보장하기 위한 개방형 표준 의미 규칙 (W3C 규칙)
마이그레이션을 지원하기 위해 여러 컨텍스트 전파 형식을 병렬로 지원
다양한 오픈소스와 상용 프로토콜 지원
오픈트레이싱, 오픈센서스를 사용항 경험이 있으면 좋음
플러그형 아키텍처로 추가 프로토콜과 포맷을 쉽게 추가 가능

33:50
레퍼런스 URL
