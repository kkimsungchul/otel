
https://youtu.be/EZmUxMtx5Fc?si=eLSLaShEMqekyrEy
※ 참고사항 해당영상은 2022년도 자료이며, 현재와는 다른내용이 있을 수 있음

# WHY

- 5:50
옵저버빌리티 (관측성, 관찰 가능성) 
시스템 혹은 애플리케이션이 어떤 데이터 값을 출력하면 
그 값을 가지고 시스템을 이해하는것
예를 들면
장애가 왜 발생했지?
왜 느려졌지?
사용자가 느끼는 속도는 빠를까?
라는 근본적인 원인을 찾는 것을 말함

모니터링과 옵저버빌리티의 차이점
모니터링은 애플리케이션에서 출력하는 값을 수집하고 확인하는 활동
옵저버빌리티는 이 모니터링 활동을 통해서 어떤 값을 가지고 근본적인 원인을 찾아가는 디버깅이 섞여있는 활동

옵저버리리티를 확보하기위해선 로그,지표,추적이 필요함
로그(log) : 로그는 시간기반 텍스트
지표(metric) : 런타임 환경에서 측정된 값
추적(trace) : 어떤 요청이 처리될 때 경로(큰그림)

로그는 시스템마다, 개발자마다 로그 규격이 다름
옵저버빌리티를 확보하는 측면에서는 구조화된 로그를 남기는 것을 권장함
구조화된 로그는, 쉽게말해 제이슨이나 프로퍼티파일에서 남기는 key:value 형태

지표는 런타임 환경에서 측정된 서비스값
대표적으로 호스트 관련 성능 지표
성능지표를 토대로 스케일아웃 또는 스케일업을 할때 기준 데이터를 정함

추적은 어떤 요청이 있을 때 어떤 시스템으로 흘러가는지, 
흘러갈때마다 시간이 얼마나 흘러가는지, 어떤 경로를 가지고 있는지 확인

옵저버빌리티 측면에서 가장 중요한건 트레이스임
성능 관련 문제가 발생했을 때 트레이스 없이는 분석하기가 힘듬

어떤 요청이 10초 걸린다고 예를 잡았을때
해당 요청에는 무수히 많은 시스템을 거처감
이럴때 로그에 어떤 요청인지, 누가요청했는지, 시간이 얼마나 걸리는지 남기면 찾을수 있음
하지만 이방법은 하나의 시스템 내에서는 쉽게 파악이 가능하지만
MSA 환경에서는 여러개의 컴포넌트들을 다 분석해야 할때는 현실적으로 어려움

- 10:50
트레이스는 추적이라고 하며, 분산추적을 의미함
트레이스는 여러개의 span으로 이뤄짐
스팬은 프로세스 처리과정 또는 그 안에서의 세부 과정을 말함
스팬에는 시작시간, 종료시간이 포함되며
트리구조다 보니 상위정보를 포함하고 있음

첫번째 스팬은 루트스팬이라고 부르며
첫번째 스팬의 소요시간을 확인하며 어떻게 돌아가는지 알수 있음

트레이스는 비동기 처리에서 더욱 빛을 발함
비동기 추적을 할때 어려움이 있음
자세한 경로를 기록하므로 개발자 혹은 운영자에게 시스템이 어떻게 돌아가는지 이해할수 있는 큰 그림을 제시해줌

-12:40
오픈텔레메트리는 간단하게 오텔이라불리며
옵저버릴리티를 도와주는 일종의 프레임워크
업계의 표준으로 자리잡고 있음
그라파나,예거,프로메테우스, 데이타독,와탭에서 오픈텔레메트리를 지원해주고있음

-13:10
오픈텔레메트리 컨셉

오픈텔레메트리는 원격 측정 데이터에 대해서
계측 수집부터 각종 API SDK등 다양한 도구를 제공하는 것을 목표로 삼고 있음
호환성 높은 모니터링 플랫폼 개발이 가능함

# HOW
다른 시스템 혹은 애플리케이션을 모니터링해야 하므로 고가용성
수많은 시스템을 모니터링 할 수 있는 능력이 필요함


17:35
모니터링플랫폼은 모니터링 어떻게?
오픈텔레메트리 콜렉터로 수집하여 관리
리시버 - 프로세스 - 익스포터

리시버 영역에서는 예거나 프로메테우스등의 각종 데이터 소스들로부터 데이터를 수신하거나 데이터를 직접 생성
생성된 데이터는 프로세스 라인을 거쳐서 
익스포터를 통해 원하는 백엔드로 전송함

공식문서, 깃허브 참고

18:30
콜렉터를 어떻게 배치하느냐에 따라서 Agent모드와 Gateway 모드로 불림
Agent모드는 애플리케이션과 동일한 호스트에서 실행
애플리케이션과 같은 레벨에서 실행

Gateway모드는 데이터 센터 또는 리전에서 독립적으로 실행, 같은 환경 내에 Agent로부터 데이터 수신
게이트웨이는 서비스 형태로 배포되는것을 말함

한 시스템 내에 6개의 서비스가 있다고 가정함
아래의 그림은 Agent 콜렉터가 없이 Gateway콜렉터만 존재함
------------------------------------------------------------
시스템 A ,시스템 B	|				|	예거			|
시스템 C ,시스템 D	| Gateway 콜렉터	|	프로메테우스	|	그라파나
시스템 E ,시스템 F	|				|	로키			|
------------------------------------------------------------
이 경우에 Gateway 콜렉터의 정보가 변경될 경우 A B C D E ...의 모든 시스템에서 정보를 변경해줘야함

여기에 Agent콜렉터를 애플케이션 레벨에 하나 추가하게되면 아래와 같은 형태로 변경되며
-----------------------------------------------------------------------
시스템 A ,시스템 B				|				|	예거			|
시스템 C ,시스템 D	Agent 콜렉터	| Gateway 콜렉터	|	프로메테우스	|	그라파나
시스템 E ,시스템 F				|				|	로키			|
-----------------------------------------------------------------------
시스템들에서 설정을 바꿀 필요없이 Agent 콜렉터에서만 Gateway콜렉터의 정보를 변경하면됨
어떻게 구성 하느냐에 따라서 콜렉터를 여러개 둘수가 있으며,
Gateway콜렉터를 여러개 구성하여 수신하는 항목을 각각 나눌수도 있음
Gateway콜렉터(metric)
Gateway콜렉터(span)
Gateway콜렉터(log)

30분부터 봐야함
http_server_requests_seconds_*
500대 에러 비율 확인 가능
초당 리퀘스트 확인
평균 응답시간 확인

500대 에러발생
-> 메트릭에서 확인
-> 트레이서 부분 확인
-> 트레이서 ID로 로그 조회


# Q&A
오픈텔레메트리 콜렉터에서 GRPC 로 리시버를 설정함
메트릭 정보를 오픈텔레메트리로 보냈는데

---
https://www.youtube.com/watch?v=uKATqtjK2eo
※ 해당 영상은 2021년9월 자료

용어와 아키텍처 설명
벤더 종속성이 없는 오픈소스기반에서의 옵저버빌리티 확보

1:05
옵저버빌리티 (관측가능성, 관찰가능성)
시스템의 속성을 자세히 설명하는데 사용하는 용어
도구들을 통해 시스템과 애플리케이션에서 발생하는 문제를 파악하는 것
원격측정(Telemetry) data

모니터링과 가장 큰 차이는
모니터링은 시스템의 상태를 확인하는거고
옵저버리리티는 시스템의 속성을 확인하고 원인분석을 통해서 장애의 근본 원인을 찾는것

Logs : 타임스탬프
Metrics : 키-밸류 태그를 가지는 집계/통계 데이터 (Gauge , Counter , Histogram 등)
Traces : 개별 Request가 전체 시스템에 전파(propagate)될 때 경로에 대한 기록

2:55
Distributed Trace(분산 추적)
시스템의 프로세스에서 특정 부분으 ㅣ지연(latency)를 알려주는 원격 측정 방법
요청이 마이크로서비스 및 서버리스 아키텍처를 통해 전파될 때 이동하는 경로를 기록
마이크로서비스 환경같은 최신 아키텍처에서 수많은 구성 요소간의 종속성과 관계를 측정하고
지연 병목을 찾아내는 도구이기 때문에 옵저버빌리티에서 매우 중요함

4:15
오픈트레이싱(OpenTracing) + 오픈센서스(OpenCensus)  = 오픈텔레메트리
오픈센서스 : 애플리케이션 메트릭과 분산 트레이스를 수집하기 위한 다양한 언어별 라이브러리 셋
오픈트레이싱 : 분산추적을 위한 벤더 중립적인 API와 계측

4:45
오픈텔레메트리란
옵저버빌리티에 필요한 데이터를 계측하고, 수집 내보내기를 해주는 도구

다양한 언어 지원
CSP : Azure , GCP , AWS 지원
모니터링 벤더 : Lightstep , Datadog , Dynatrace , Honeycomb, New Relic , Splunk, Stackdriver
벤더사에서는 대부분 오픈텔레메트리를 지원해주며, 해당 규격으로 개발을 하고 있음

9:11
컨텍스트 전파(Context Propagation)
Core Concept : 서비스간 트레이스 전달 규약 (W3C, Zipkin B3)

오픈텔레메트리의 핵심은 개발자가 보고싶을때 컨텍스트를 제공해주는 것

10:15
Trace : 서비스 요청에 대한 애플리케이션 또는 서비스 구조 확인하고,
모든 서비스들 간 데이터 흐름을 시각화하여 아키텍처상의 병목 현상을 파악

Span : 다양한 정보를 캡슐화(encapsulate)

전체의 흐름을 트레이스로 보고
그 안에 있는 정보들을 스팬, 스팬에는 부모 자식 스팬이 있음

11:50
Spans
Name , Timestamp(start , finish)
Attributes : 자유롭게 추가 가능한 키-벨류(Customer ID , Version , Host ID, 애플리케이션 버전 등)
Events : 타임스탬프 문자열 형태의 tuple(name, timestamp , attributes)
Links : span의 인과 관계
SpanContext : Span이 참조하는데 필요한 정보
TraceId : 전체 시스템 식별자, WorldWide 식별자(16 bytes array identifier)
SpanID (ParendId) : 서비스 레벨에서의 글로벌 변수, Globally in a service(8 Bytes array identifier)
TraceFlags : Optional , Sampling bit( 1 byte(8bit) , But only 1bit Used)
TraceState : Optional 키-밸류( ex, 벤더 식별 정보)

13:30
W3C Trace Context
상관 정보에 대한 전달 방법 표준
TraceParent : trace-id(TraceId) , span-id(SpanId) , sampling flag(TraceFlags)
TraceState

Baggage : 메트릭, 추적 및 로그에 사용자가 원하는 컨텍스트와 정보를 추가하는데 사용
 baggage : userId = alice , baggage : serverNode=node01
 https://w3c.github.io/baggage/

14:20
컨텍스트 도식화
UML다이어그램

trace ID
-> 스팬 시작 (trace ID , span ID)
->> 자식 스팬 시작 (trace ID , parent span ID , span ID)
->>> 자식 스팬 시작 (trace ID , parent span ID , span ID)
위의 내용에서 trace ID는 모두 똑같음
span ID는 해당 span의 고유 ID이며, parent span ID는 바로 상위의 span ID


16:20
오픈텔레메트리 아키텍처 설명

17:50
콜렉터 도식화

18:40
콜렉터 설명
리시버 ,프로세스,익스포터

메모리제약
배치 제약
샘플링 비율 (저장되는 트레이싱의 볼륨 설정)

20:22
파이프라인 구성 용이
백엔드 선택 자유
운영에 대한 용이성, 중앙에서 운영

콜렉터 성능
2018년도 구글 서밋에서 발표한 내용
1 collector , 24 core 48GB
초당 20만 Spans (17.3 billion span/day)
57TB/day
no dropped spans  (유실된 span이 하나도 없음)

21:15
자체 구축 데모 설명


23:00
Spring 구성 설명
Actuator , prometheus 사용해서 어플리케이션에서 바로 툴로 전송

24:30
Spring 수동 설정 (SDK)
어노테이션 사용방법 설명

데모 시연

30:30
샘플링
Span , Metric 에 key : value를 추가하게되면 데이터에 엄청난 비용이 발생할 수 있음
자체적으로 샘플링을 해서 데이터 수집에 대한 비용을 낮출수 있음
다만 샘플링 비율을 너무 높게 하면, 데이터 비용이 높고
너무 낮게하면 오차가 너무 심함
샘플링 값을 테스트 하여 원하는 샘플링 정책을 가져가는게 좋음

32:00
오픈텔레메트리 정리
벤더 중립적인 단일 계측 라이브러리(자동 및 수동 계측 모두 지원)
에이전트 또는 게이트웨이를 포함해 다양한 방법으로 배포할 수 있는 단일 콜렉터 바이너리
환경 구성을 통해 데이터를 여러 대상에 병렬로 전송 가능
데이터 수집을 보장하기 위한 개방형 표준 의미 규칙 (W3C 규칙)
마이그레이션을 지원하기 위해 여러 컨텍스트 전파 형식을 병렬로 지원
다양한 오픈소스와 상용 프로토콜 지원
오픈트레이싱, 오픈센서스를 사용항 경험이 있으면 좋음
플러그형 아키텍처로 추가 프로토콜과 포맷을 쉽게 추가 가능

33:50
레퍼런스 URL
---


AWS에서 OpenTelemetry 기반의 애플리케이션 Observability 구축/활용하기 - 최철우 솔루션즈 아키텍트, AWS :: AWS Summit Seoul 2023
https://www.youtube.com/watch?v=_p3akzsWXw4

1:00
옵저버빌리티의 정의
시스템안의 상태와 동작을 관잘하고 측정함으로써 시스템에서 일어나는 일을 잘 이해하는 것

시스템이 복잡해지고 시스템마다 적절한 가시성이 필수임
이러한 환경이 적절히 구성되지 않는다면, 어디서 문제가 발생했는지 알기 어려움
옵저버빌리티는 트러블슈팅이나 시스템을 디버깅 하는데 필수적

텔레메트리
시스템의 동작과 성능에 대한 데이터, 매트릭 로그 트레이스

서비스에 문제가 생겼을때 어디서 어떤 문제가 생겼는지 식별 가능해야함
느려졌을때 빨리 찾을  수 있어어함

2:15
기존 방식 설명
로그스태시 아파티 플롬
프로메테우스 그라파나
오픈트레이싱 오픈센서스 예거 지킨

각각의 에이전트 또는 백엔드를 구성하여 텔레메트리 데이터를 수집함
만약에 트레이싱 방식을 변경하려고 하면, 변경된 라이브러리 ,에이전트, 백엔드를 변경해야 하며
많게는 소스까지 수정해야 하는 상황이 생김

저장된 데이터를 상호연관해서 보기도 힘듬




3:30
오픈텔레메트리 소개
오픈트레이싱+오픈센서스가 합쳐짐
오픈텔레메트르의 목적은 데이터 생성,수집,전송의 표준화

개방형 표준, 특정 벤더 의존적이지 않음
한번만의 계측으로 수집/통합해서 여러 타깃으로 전달
각 언어별 SDK , API계측 라이브러리 지원
여러가지 방식으로 배포할 수 있는 단일 수집기
메시지 프로토콜
CNCF의 인기 프로젝트

4:25
오픈텔레메트리 메시지 타입
트레이싱 : 어떤 요청이 처리되는 전체 경로
매트릭 : 실행중인 시스템의 상태에 대한 정보
로그 : 타임스탬프가 있는 텍스트 레코드
배기지 : Span간에 전달이 필요한 컨텍스트 정보

6:40
오픈텔레메트리 구현체

콜렉터는 메시지를 효율적으로 받아서 처리하고 보내는 애

7:40
AWS 에서는 ADOT (AWS Distro for OpenTelemetry) 를 제공해줌
CNCF Project의 업스트림 배포판
계측을 위한 API , Library , Agent , Collector 제공
EC2 , ECS , EKS , Lambda 사용가능
AWS Support 지원

8:45
리시버 : 메시지 유형에 따라 소스로부터 메시지 수집
프로세서 : 목적지로 전송하기 전에 메시지 데이터를 프로세싱함
원하지 않는 메시지 필터링 , 메시지 추가, 정기적인 버퍼링

익스포터 : 원하는 목적지로 메시지 데이터 전송
익스텐션 : 콜렉터의 기능을 확장

10:20
자동계측예제

11:30
콜렉터 실행



---

NHN FORWARD 22 OpenTelemetry를 활용한 모니터링
https://www.youtube.com/watch?v=EZmUxMtx5Fc

0
도입목표: 사내 서버에서만 사용 가능하던 기존 레거시 모니터링 플랫폼의 제거 및 모니터링 생태계 내에서 높은 호환성을 가지는 모니터링 시스템의 구축
기존 시스템의 문제점 1:
멀티클라우드 환경에서 시스템을 구축하고 운영하는 사례가 많이 있음
ex) 어떤 시스템을 NHN 클라우드에 배포 후, aws 등 타클라우드에도 배포
평상시에는 NHN 클라우드에 있는 서비스로 서비스를 하다가 사용 불가 시 타 클라우드에 있는 시스템으로 서비스를 하게 됨.
이렇게 하기 위해서는 타 클라우드에 있는 시스템도 모니터링이 가능해야 하는데 레거시 모니터링 플랫폼에서는 불가능함
이유는 내부적으로 hostid라는 서버를 구분하는 값을 사용하고 있었는데, 타클라우드를 지원하려면 해당 hostid를 다른 값으로 대체해야 하기 때문에
전반적으로 로직을 변경해야 함
기존 시스템의 문제점 2:
레거시 모니터링 시스템에서는 지표만 가능. 또한 호스트 관련 지표는 RDB에 저장하고 어플리케이션 지표는 TSDB에 저장을 하기 때문에
사용자가 조회하고자 하는 지표에 따라서 어떤 API를 호출해야 하는지 직접 선택해야 함
기존 시스템의 문제점 3:
모니터링 생태계 내에서 쓰이는 프로메테우스 등 다른 도구들과의 호환이 필요함

6:10
Observability(관측성, 관찰 가능성)
시스템 혹은 어플리케이션이 출력하는 데이터 값으로 시스템을 이해하는 것
ex) 장애가 왜 발생했지? 시스템이 왜 느려지지? 사용자가 느낀 속도는 빠를까? 이런 질문에 대한 근본적인 원인을 찾는 것
=> cpu 테스트로 서버 부하를 가했을 때 마우스가 느려지는 현상 -> 그라파나로 시연하면 괜찮을까?

6:45
모니터링과 옵저버빌리티와의 관계
Log: 시간 기반 텍스트 (+ logger name, thread name, ip, ..)
 텍스트 데이터이다 보니까 포맷이 자유로움. 따라서 분석하고 파싱하는 과정이 필요 - 파싱하는 로직이 복잡해질 수 있음
 옵저버빌리티 체계를 확보하기 위해 구조화된 로그를 남기는 것을 권장하고 있음
Metrics: 런타임 환경에서 측정된 값 (+ host 관련 성능지표)
 시스템을 구축하고 운영하는 과정에서 scale out이나 scale up을 할 때 기준 지표로 삼고 있기 때문에 중요함
Trace: 어떤 요청이 처리될 때 경로(큰 그림)
 경로를 통해 시스템이 어떻게 돌아가고 있는지 확인 가능함. 성능 관련 문제가 생겼을 때 Trace 없이는 판단하기가 어려움
 어떤 요청이 10초 걸린다고 했을 때, 무수히 많은 시스템을 거쳐 가기 때문에 각각 경로에 대한 기록이 없다면 알기 어려움
 로그에 어떤 요청이 들어왔고, 누가 요청을 했고, 어떤 실행 경로가 있는지 알 수 있음
 어떤 컴포넌트를 호출하는지 확인하려면 로그에 정보를 남겨서 분석하는 데에 현실적으로 어렵기 때문에 Trace가 중요함

10:37
Trace: 여러 개의 Span으로 이루어지는 단위
Span: 프로세스 처리 과정 및 세부적인 과정(시작 시간, 종료 시간 포함 및 트리 구조여서 상위 스팬이 어떤 것인지 정보를 가지고 있음)
32ms 안에 어떤 컴포넌트를 거쳐가는지, 시간이 얼마나 소요되는지 트레이스를 통해 시스템이 어떻게 돌아가는지 이해할 수 있음
비동기 처리할 때에도 매우 유용함 -> 클라이언트에서 느끼는 속도와 서버 쪽 속도를 나눠서 설명하면 좋을 것 같음

12:41
Opentelemetry: 옵저버빌리티를 도와주는 Framework

13:08
Opentelemetry 설명 그림
Application: Otel에서 제공하는 API, SDK를 통해서 OTLP 형식으로 Export함
K8s, L7 Proxy, Shared Intra: OTLP 형식으로 Export함
Otel Collector: OTLP 형식으로 데잍 Import 및 다른 Frontend&API로 데이터 Export

15:00
어떻게 모니터링 문제를 해결했는지
Cerebrate
Springboot + Spring Cloud 기반으로 MSA 스타일로 구현
Email 기능
멀티테넌시 지원(나만 조회, 내가 초대한 사람만 조회 - OAuth2 스펙으로 구현)

17:35
어떻게 모니터링 하고 있는지? + Otel collector 그림
Receiver 영역: 예거나 프로메테우스 데이터 소스들 수신 or 데이터 생성
프로세서 영역
Exporter 영역: 원하는 백엔드로 전송

20:17
Otel collector를 적용하기 전: aggregator로 보내고 loki로 전송을 함
호스트 지표는 n사이트로 수집을 하고 있음
기타 애플리케이션 지표는 프로메테우스가 담당
데이터 조회 시 두 가지 url을 사용해야 하기 때문에 불폄함

Otel collector를 적용한 후
n사이트 agent 없어짐
otel 게이트 에이전트가 지킨 리시버나 예거리시버를 통해서 데이터 수신 및 게이트웨이로 보냄
각각의 알맞은 데이터를 원하는 백엔드에 저장
spring 기반 application에서 jaeger가 알아들을 수 있는 format으로 보냄

31:01
11시 8분의 데이터를 보면 100개 중 99개는 늦어도 200ms 안에 응답
100개의 요청 중 95개는 늦어도 180ms 안에 응답
-> 시스템 서비스를 만들 때 비즈니스 요구사항 외에도 성능 요구사항이
대부분의 유저(98%의 유저, 95%의 유저)는 1초 안에 응답을 받아야 한다가 있기 때문에
어플리케이션은 수시로 변화하기 때문에
매번 배포 시 부하테스트를 하기에는 현실적으로 어려움
따라서 현재의 시스템의 상태를 확인하고 예측하는 것이 좋음

5xx 에러 비율 2xx 비율
5xx 에러가 없는데 2xx 에러가 감소한다? -> 4xx 요청이 많다 -> 클라이언트가 잘못하는 것
-> 제공하는 api 가이드에 에러가 있는 건지? 허용하지 않는 태넌트에 접근을 하는 건지 판단 가능

5xx 에러 데이터를 일부러 발생시키고 어떻게 trouble shootingㅇ르 하는가?
평균 응답 시간 -> 늘어나는 경우 해당 api에 문제가 있는 것
대부분의 유저가 80ms 안에 응답이 가능하다고 판단하고 있음

api 통신을 해서 5xx 에러를 발생시키고 있음 (서버 죽이기)
-> 점점 증가하는가? 확인해야 함 -> 어떻게 해야 할까?
-> 어떤 api에서 에러가 나는지를 알고 있기 대문에
해당 정보를 가지고 trace를 볼 것 -> jaeger로 tags env = dev http.stuatus_code=500
해당하는 trace 중 하나를 복사해서 해당 trace에 대한 상세 정보를 확인할 필요가 있음
인증 서버까지 거쳐 갔고, 해당 서버에서 에러가 났는지 확인
-> 로그 조회하기. cortex server의 gateway가 이상함을 확인 가능함 -> cortex gateway를 확인하면 됨